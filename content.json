{"meta":{"title":"鲍一凡的博客","subtitle":"","description":"","author":"BYF","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"基础算法常用模板3","date":"2022-10-26T14:28:31.000Z","updated":"2022-10-26T14:42:19.809Z","comments":true,"path":"2022/10/26/基础算法常用模板3/","link":"","permalink":"http://example.com/2022/10/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF3/","excerpt":"基础算法——常用模板3","text":"基础算法——常用模板3 树与图的存储树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。 (1) 邻接矩阵：g[a][b] 存储边a-&gt;b (2) 邻接表 123456789101112// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h); 树与图的遍历时间复杂度 O(n+m), n表示点数，m表示边数深度优先遍历 12345678910int dfs(int u)&#123; st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) dfs(j); &#125;&#125; 宽度优先遍历 12345678910111213141516171819queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; // 表示点j已经被遍历过 q.push(j); &#125; &#125;&#125; 拓扑排序时间复杂度 O(n+m), n表示点数，m表示边数 123456789101112131415161718192021222324bool topsort()&#123; int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) &#123; int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; &#125; &#125; // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1;&#125; 朴素dijkstra算法时间复杂是 O(n^2+m), n表示点数,m表示边数 123456789101112131415161718192021222324252627int g[N][N]; // 存储每条边int dist[N]; // 存储1号点到每个点的最短距离bool st[N]; // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) &#123; int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125; 堆优化版——dijkstra时间复杂度 O(mlogn),n表示点数,m表示边数 123456789101112131415161718192021222324252627282930313233343536373839typedef pair&lt;int, int&gt; PII;int n; // 点的数量int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N]; // 存储所有点到1号点的距离bool st[N]; // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push(&#123;0, 1&#125;); // first存储距离，second存储节点编号 while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; if (dist[j] &gt; distance + w[i]) &#123; dist[j] = distance + w[i]; heap.push(&#123;dist[j], j&#125;); &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125; Bellman-Ford算法复杂度O(n*m),n为点数，m为边数 12345678910111213141516171819202122232425262728int n, m; // n表示点数，m表示边数int dist[N]; // dist[x]存储1到x的最短路距离struct Edge // 边，a表示出点，b表示入点，w表示边的权重&#123; int a, b, w;&#125;edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i &lt; n; i ++ ) &#123; for (int j = 0; j &lt; m; j ++ ) &#123; int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] &gt; dist[a] + w) dist[b] = dist[a] + w; &#125; &#125; if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n];&#125; spfa 算法（队列优化的Bellman-Ford算法） 12345678910111213141516171819202122232425262728293031323334353637383940int n; // 总点数int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N]; // 存储每个点到1号点的最短距离bool st[N]; // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) &#123; auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 &#123; q.push(j); st[j] = true; &#125; &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125; spfa判断图中是否存在负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344int n; // 总点数int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N]; // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa()&#123; // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) &#123; q.push(i); st[i] = true; &#125; while (q.size()) &#123; auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) &#123; q.push(j); st[j] = true; &#125; &#125; &#125; &#125; return false;&#125; floyed算法 1234567891011121314初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123; for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; 朴素版prim算法 1234567891011121314151617181920212223242526272829int n; // n表示点数int g[N][N]; // 邻接矩阵，存储所有边int dist[N]; // 存储其他点到当前最小生成树的距离bool st[N]; // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim()&#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) &#123; int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); &#125; return res;&#125; **Kruskal算法 ** 123456789101112131415161718192021222324252627282930313233343536373839404142int n, m; // n是点数，m是边数int p[N]; // 并查集的父节点数组struct Edge // 存储边&#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125;&#125;edges[M];int find(int x) // 并查集核心操作&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal()&#123; sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 &#123; p[a] = b; res += w; cnt ++ ; &#125; &#125; if (cnt &lt; n - 1) return INF; return res;&#125; 染色法判别二分图 12345678910111213141516171819202122232425262728293031323334int n; // n表示点数int h[N], e[M], ne[M], idx; // 邻接表存储图int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c)&#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (color[j] == -1) &#123; if (!dfs(j, !c)) return false; &#125; else if (color[j] == c) return false; &#125; return true;&#125;bool check()&#123; memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) &#123; flag = false; break; &#125; return flag;&#125; 匈牙利算法 12345678910111213141516171819202122232425262728293031int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过bool find(int x)&#123; for (int i = h[x]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; if (match[j] == 0 || find(match[j])) &#123; match[j] = x; return true; &#125; &#125; &#125; return false;&#125;// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ )&#123; memset(st, false, sizeof st); if (find(i)) res ++ ;&#125;","categories":[],"tags":[]},{"title":"","slug":"基础算法常用模板2","date":"2022-10-25T15:57:00.000Z","updated":"2022-10-25T15:58:15.203Z","comments":true,"path":"2022/10/25/基础算法常用模板2/","link":"","permalink":"http://example.com/2022/10/25/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF2/","excerpt":"基础算法——常用模板2","text":"基础算法——常用模板2 单链表 123456789101112131415161718192021// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 在链表头插入一个数avoid insert(int a)&#123; e[idx] = a, ne[idx] = head, head = idx ++ ;&#125;// 将头结点删除，需要保证头结点存在void remove()&#123; head = ne[head];&#125; 双链表 12345678910111213141516171819202122232425// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 栈——模板题 1234567891011121314151617// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0)&#123;&#125; 队列——模拟题 1234567891011121314151617// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt)&#123;&#125; 循环队列 12345678910111213141516171819// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt)&#123;&#125; 单调栈——模拟题 1234567常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;&#125; 单调队列——模板 12345678常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; KMP——模板题 1234567891011121314151617181920// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; Trie数——模板 123456789101112131415161718192021222324252627282930int son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125; cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 并查集——模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[i] = 0; &#125; // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆——模板题 123456789101112131415161718192021222324252627282930313233343536// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i); 一般哈希——模板题 12345678910111213141516171819202122232425262728293031323334353637(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; &#125; // 在哈希表中查询某个数是否存在 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; &#125;(2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) &#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t; &#125; 字符串哈希——模板 12345678910111213141516171819核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125; C++ STL简介 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反","categories":[],"tags":[]},{"title":"","slug":"基础算法常用模板1","date":"2022-10-25T11:07:30.854Z","updated":"2022-10-25T11:07:32.712Z","comments":true,"path":"2022/10/25/基础算法常用模板1/","link":"","permalink":"http://example.com/2022/10/25/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF1/","excerpt":"基础算法——常用模板1","text":"基础算法——常用模板1 快速排序模板 12345678910111213void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 归并排序模板 123456789101112131415161718void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125; 整数二分模板 123456789101112131415161718192021222324bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 浮点数二分模板 12345678910111213bool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123; const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125; 高精度加法模板 123456789101112131415161718// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(t); return C;&#125; 高精度减法模板 12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度乘法 1234567891011121314151617// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 高精度除法 123456789101112131415// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125; 一维前缀和模板 12S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1] 二维前缀和模板 123S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分模板 1给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维差分模板 12给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针模板 123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化模板 12345678910111213141516vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 区间合并模板 1234567891011121314151617181920// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed &lt; seg.first) &#123; if (st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); if (st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}